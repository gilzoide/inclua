{{ info.C_NOTICE }}
{%
-- Transform ' ' to '_', for things such as "struct Name" to "struct_Name"
local function space2_(s)
	res, _ = s:gsub(' ', '_')
	return res
end

-- Is record/enum anonymous?
local function is_anonymous(n)
	return string.match(n.name, "%w+ anonymous")
end

-- Is recod opaque?
local function is_opaque(r)
	return r.notes == "opaque" or #r.type.fields == 0
end
%}
/* Inclua Lua wrapper generator
 * ============================
 * What you should know:
 * 
 * - generated code is C++11
 * - nothing is defined in global scope, everything is in the module table
 * - doesn't yet support input default arguments
 * - non opaque structs/unions can be instantiated with the `new` function from
 *   it's metatable: `obj = my_module.struct_metatable.new ()`
 * - all structs/unions may index it's metatable if the key isn't present as a
 *   field. This way it is easy to include methods (and metamethods):
 *   `my_module.struct_metatable.__tostring = my_module.print_struct
 *   print(some_struct_in_memory)
 *   my_module.struct_metatable.someFunc = my_module.someFunc
 *   some_struct_in_memory:someFunc(extra_args)`
 * - every struct/union pointer is a Lua full userdata, which means that equality
 *   between pointers doesn't work like expected. This will be fixed soon
 * - all output parameters that are pointers are initialized with NULL, as some
 *   functions may relly on that to know if it worked
 * - structs/unions that have function pointers as fields cannot be bound
 */

#ifndef INCLUA_LUA_HPP
#define INCLUA_LUA_HPP

#include "lua.hpp"
#include <cstdlib>
#include <cstring>
#include <cstdint>
#include <type_traits>

////////////////////////////////////////////////////////////////////////////////
//  Native types
////////////////////////////////////////////////////////////////////////////////
template<typename T> void inclua_push(lua_State *L, T val) {
	typedef typename std::remove_cv<T>::type noCV;
	static_assert(!std::is_same<T, noCV>::value, "Type not yet registered in inclua_push");
	inclua_push<noCV>(L, val);
}

template<> void inclua_push(lua_State *L, bool b) {
	lua_pushboolean(L, b);
}

template<> void inclua_push(lua_State *L, char c) {
	lua_pushlstring(L, &c, sizeof (char));
}

template<> void inclua_push(lua_State *L, int8_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, int16_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, int32_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, int64_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, long long int i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, uint8_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, uint16_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, uint32_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, uint64_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, unsigned long long int i) {
	lua_pushinteger(L, i);
}

template<> void inclua_push(lua_State *L, float flt) {
	lua_pushnumber(L, flt);
}
template<> void inclua_push(lua_State *L, double flt) {
	lua_pushnumber(L, flt);
}
template<> void inclua_push(lua_State *L, long double flt) {
	lua_pushnumber(L, flt);
}

template<> void inclua_push(lua_State *L, const char *str) {
	if(str) {
		lua_pushstring(L, str);
	}
	else {
		lua_pushnil(L);
	}
}
template<> void inclua_push(lua_State *L, char *str) {
	if(str) {
		lua_pushstring(L, str);
	}
	else {
		lua_pushnil(L);
	}
}

template<> void inclua_push(lua_State *L, void *ptr) {
	lua_pushlightuserdata(L, ptr);
}


template<typename T> T inclua_check(lua_State *L, int arg) {
	typedef typename std::remove_cv<T>::type noCV;
	return inclua_check<noCV>(L, arg);
}

template<> bool inclua_check(lua_State *L, int arg) {
	return lua_toboolean(L, arg);
}

template<> char inclua_check(lua_State *L, int arg) {
	return *luaL_checkstring(L, arg);
}

template<> int8_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> int16_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> int32_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> int64_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> long long int inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> uint8_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> uint16_t inclua_check (lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> uint32_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> uint64_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> unsigned long long int inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}

template<> float inclua_check(lua_State *L, int arg) {
	return luaL_checknumber(L, arg);
}
template<> double inclua_check(lua_State *L, int arg) {
	return luaL_checknumber(L, arg);
}
template<> long double inclua_check(lua_State *L, int arg) {
	return luaL_checknumber(L, arg);
}

template<> const char *inclua_check(lua_State *L, int arg) {
	return lua_isnoneornil(L, arg) ? NULL : luaL_checkstring(L, arg);
}

template<> void *inclua_check(lua_State *L, int arg) {
	void *ptr = lua_touserdata(L, arg);
	// if full userdata, do the uservalue trick
	if(lua_type(L, arg) == LUA_TUSERDATA) {
		if(lua_getuservalue(L, arg) != LUA_TBOOLEAN) {
			ptr = *((void **) ptr);
		}
		lua_pop(L, 1);
	}
	return ptr;
}

////////////////////////////////////////////////////////////////////////////////
//  Records: Structs/Unions
////////////////////////////////////////////////////////////////////////////////
#define INCLUA_PUSH(record_name) \
	template<> void inclua_push(lua_State *L, record_name *ptr) { \
		if(ptr) { \
			record_name **block = (record_name **) lua_newuserdata (L, sizeof (void *)); \
			luaL_setmetatable(L, #record_name); \
			*block = ptr; \
		} \
		else { \
			lua_pushnil(L); \
		} \
	}

#define INCLUA_PUSH_NON_OPAQUE(record_name) \
	template<> void inclua_push(lua_State *L, record_name obj) { \
		record_name **block = (record_name **) lua_newuserdata(L, sizeof(void *)); \
		luaL_setmetatable(L, #record_name); \
		*block = &obj; \
	}

#define INCLUA_CHECK(record_name) \
	template<> record_name *inclua_check(lua_State *L, int arg) { \
		if (lua_isnoneornil(L, arg)) { \
			return NULL; \
		} \
		else { \
			record_name *ptr = (record_name *) luaL_checkudata(L, arg, #record_name); \
			if (lua_getuservalue(L, arg) != LUA_TBOOLEAN) { \
				ptr = *((record_name **) ptr); \
			} \
			lua_pop(L, 1); \
			return ptr; \
		} \
	}

#define INCLUA_CHECK_NON_OPAQUE(record_name) \
	template<> record_name inclua_check(lua_State *L, int arg) { \
		return *(inclua_check<record_name *>(L, arg)); \
	}

////////////////////////////////////////////////////////////////////////////////
//  Enums
////////////////////////////////////////////////////////////////////////////////
#define INCLUA_PUSH_ENUM(enum_name) \
	template<> void inclua_push(lua_State *L, enum_name value) { \
		inclua_push<int>(L, value); \
	}

#define INCLUA_CHECK_ENUM(enum_name) \
	template<> enum_name inclua_check(lua_State *L, int arg) { \
		return (enum_name) inclua_check<int>(L, arg); \
	}

////////////////////////////////////////////////////////////////////////////////
//  Array types
////////////////////////////////////////////////////////////////////////////////

template<typename T, typename = std::enable_if<std::is_pointer<T>::value>>
void inclua_push_array(lua_State *L, T arr, size_t size) {
	lua_newtable (L);
	for(int i = 0; i < size; i++) {
		inclua_push(L, arr[i]);
		lua_seti(L, -2, i + 1);
	}
}
template<typename T, typename = std::enable_if<std::is_pointer<T>::value>, typename... Sizes>
void inclua_push_array(lua_State *L, T arr, size_t size, Sizes... tail) {
	lua_newtable(L);
	for(int i = 0; i < size; i++) {
		inclua_push_array(L, arr[i], tail...);
		lua_seti(L, -2, i + 1);
	}
}
template<>
void inclua_push_array(lua_State *L, char *arr, size_t size) {
	// char array? Ah, string it is!
	lua_pushlstring(L, arr, size);
}


#define remove_cv_from_ptr(T) typename std::remove_cv<typename std::remove_pointer<T>::type>::type
template<typename T, typename = std::enable_if<std::is_pointer<T>::value>>
T inclua_check_array(lua_State *L, int arg, size_t * size) {
	typedef remove_cv_from_ptr(T) pointeeType;
	// check for NULL array
	if(lua_isnoneornil(L, arg)) {
		if(size) {
			*size = 0;
		}
		return NULL;
	}

	int len = luaL_len(L, arg);
	luaL_argcheck(L, len >= 0, arg, "Array length should be a positive integer");
	if(size) {
		*size = len;
	}
	pointeeType * ret = new pointeeType[len];
	arg = lua_absindex(L, arg);
	for(int i = 0; i < len; i++) {
		lua_geti(L, arg, i + 1);
		ret[i] = inclua_check<pointeeType>(L, -1);
	}
	lua_pop(L, len);
	return ret;
}
template<typename T, typename = std::enable_if<std::is_pointer<T>::value>, typename... Sizes>
T inclua_check_array(lua_State *L, int arg, size_t * size, Sizes... tail) {
	typedef remove_cv_from_ptr(T) pointeeType;
	// check for NULL array
	if(lua_isnoneornil(L, arg)) {
		if(size) {
			*size = 0;
		}
		return NULL;
	}

	int len = luaL_len(L, arg);
	luaL_argcheck(L, len >= 0, arg, "Array length should be a positive integer");
	if(size) {
		*size = len;
	}
	pointeeType * ret = new pointeeType[len];
	arg = lua_absindex(L, arg);
	for(int i = 0; i < len; i++) {
		lua_geti(L, arg, i + 1);
		ret[i] = inclua_check_array<pointeeType>(L, -1, tail...);
	}
	lua_pop(L, len);
	return ret;
}
template<>
const char * inclua_check_array(lua_State *L, int arg, size_t * size) {
	// char array? Ah, string it is!
	return luaL_checklstring(L, arg, size);
}


template<typename T, typename = std::enable_if<std::is_pointer<T>::value>>
T inclua_new_array(size_t size) {
	typedef remove_cv_from_ptr(T) pointeeType;
	return new pointeeType[size];
}
template<typename T, typename = std::enable_if<std::is_pointer<T>::value>, typename... Sizes>
T inclua_new_array(size_t size, Sizes... tail) {
	typedef remove_cv_from_ptr(T) pointeeType;
	auto ret = new pointeeType[size];
	for(size_t i = 0; i < size; i++) {
		ret[i] = inclua_new_array<pointeeType>(tail...);
	}
	return ret;
}


template<typename T, typename = std::enable_if<std::is_pointer<T>::value>>
void inclua_delete_array(T arr) {
	delete[] arr;
}
template<typename T, typename = std::enable_if<std::is_pointer<T>::value>>
void inclua_delete_array(T arr, size_t size) {
	for (size_t i = 0; i < size; i++) {
		inclua_delete_array(arr[i]);
	}
	delete[] arr;
}
template<typename T, typename = std::enable_if<std::is_pointer<T>::value>, typename... Sizes>
void inclua_delete_array(T arr, size_t size, Sizes... tail) {
	for (size_t i = 0; i < size; i++) {
		inclua_delete_array(arr[i], tail...);
	}
	delete[] arr;
}

template<>
void inclua_delete_array(const char * arr) {
	// in Lua, the strings from luaL_checkstring are internal, so no need to delete'em
}

#undef remove_cv_from_ptr
#endif

{% for _, h in ipairs(headers) do %}
#include "{{ h }}"
{% end %}

{% --- PUSH/CHECK --- %}
{% for _, r in ipairs(records) do %}
// Push/Check {{ r.alias or r.name }} 
{%   if is_anonymous(r) then %}
{{ r.name }} {
{%     for _, field in ipairs(r.type.fields) do %}
	{{ field[2].spelling }} {{ field[1] }};
{%     end %}
};
{%   elseif not is_opaque(r) then %}
INCLUA_PUSH_NON_OPAQUE({{ r.name }});
INCLUA_CHECK_NON_OPAQUE({{ r.name }});
{%   end %}
INCLUA_PUSH({{ r.name }});
INCLUA_CHECK({{ r.name }});
{% end %}

{% for _, e in ipairs(enums) do %}
////////////////////////////////////////////////////////////////////////////////
//  {{ e.alias or e.name }} 
////////////////////////////////////////////////////////////////////////////////
{%   if not is_anonymous(e) then %}
INCLUA_PUSH_ENUM({{ e.name }});
INCLUA_CHECK_ENUM({{ e.name }});
{%   else %}
// Anonymous
{%   end %}
void inclua_register_{{ space2_(e.name) }}(lua_State *L) {
{%   for _, v in ipairs(e.values) do %}
	inclua_push<int>(L, {{ v.name }}); lua_setfield(L, -2, "{{ v.alias or v.name }}");
{%   end %}
}
{% end %}

{% for _, r in ipairs(records) do %}
{%   local normalized = space2_(r.name) %}
////////////////////////////////////////////////////////////////////////////////
//  {{ r.alias or r.name }} 
////////////////////////////////////////////////////////////////////////////////
{%   if not is_opaque(r) then %}
{%     if not is_anonymous(r) then %}
int inclua_push_new_{{ normalized }}(lua_State *L) {
	lua_newuserdata(L, sizeof ({{ r.name }}));
	luaL_setmetatable(L, "{{ r.name }}");
	// Mark userdata as non-pointer
	lua_pushboolean(L, 1);
	lua_setuservalue(L, -2);
	return 1;
}
{%     end %}
int inclua_index_{{ normalized }}(lua_State *L) {
	{{ r.name }} *obj = inclua_check<{{ r.name }}>(L, 1);
	const char *key = inclua_check<const char *>(L, 2);

{%     for i, f in ipairs(r.type.fields) do
         local els = i == 1 and "" or "else "
		 local field, ty = f[1], f[2]
		 local ref = ty.kind == "record" and (is_anonymous(ty) and "(" .. ty.name .. " *) &" or "&") or ""
%}
	{{ els }}if(strcmp(key, "{{ field }}") == 0) inclua_push(L, {{ ref }}obj->{{ field }});
{%     end %}
	else return luaL_error (L, "{{ r.alias or r.name }} doesn't have a \"%s\" field", key);
}
{%   end %}

void inclua_register_{{ normalized }}(lua_State *L) {
	if(luaL_newmetatable(L, "{{ r.name }}")) {
{%   if is_opaque(r) then %}
		lua_pushvalue (L, -1);
		lua_setfield(L, -2, "__index");
{%   else %}
		const luaL_Reg metamethods[] = {
			{ "__index", inclua_index_{{ normalized }} },
			{ "__newindex", inclua_new_index_{{ normalized }} },
{%     if not is_anonymous(r) then %}
			{ "new", inclua_push_new_{{ normalized }} },
{%     end %}
			{ NULL, NULL },
		};
		luaL_setfuncs(L, metamethods, 0);
{%   end %}
		lua_pushliteral(L, "{{ r.name }}");
		lua_setfield(L, -2, "__metatable");
	}
}
{% end %}

////////////////////////////////////////////////////////////////////////////////
//  Module initialization
////////////////////////////////////////////////////////////////////////////////
extern "C" int luaopen_{{ module_name }}(lua_State *L) {
	const luaL_Reg functions[] = {
{% for _, f in ipairs(functions) do %}
		{ "{{ f.alias or f.name }}", wrap_{{ f.name }} },
{% end %}
		{ NULL, NULL },
	};
	luaL_newlib(L, functions);

{% for _, r in ipairs(records) do %}
{%   local name = r.alias or r.name %}
	// {{ name }} 
	inclua_register_{{ space2_(r.name) }}(L);
	lua_setfield(L, -2, "{{ name }}");

{% end %}
{% for _, e in ipairs(enums) do %}
{%   local name = e.alias or e.name %}
	// {{ name }} 
{% if e.notes == 'scope' then %}	lua_newtable(L);{% end %}
	inclua_register_{{ space2_(e.name) }}(L);
{% if e.notes == 'scope' then %}	lua_setfield(L, -2, "{{ name }}");{% end %}
	
{% end %}
{% for k, v in pairs(constants) do %}
	// constant {{ k }} 
	inclua_push(L, {{ v }});
	lua_setfield(L, -2, "{{ k }}");

{% end %}
	// lua_State for function arguments
	//callback_State = L;

	return 1;
}
