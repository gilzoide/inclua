{{ info.C_NOTICE }}
{%
local tablex = require "pl.tablex"
-- Transform ' ' to '_', for things such as "struct Name" to "struct_Name"
local function space2_(s)
	res, _ = s:gsub(' ', '_')
	return res
end

-- Trim "struct", "enum" and "union" prefixes
local function trim_prefix(s)
	return string.match(s, " (.+)") or s
end

-- Is record/enum anonymous?
local function is_anonymous(n)
	return string.match(n.name, "%w+ anonymous")
end

-- Is record opaque?
local function is_opaque(r)
	return r.notes == "opaque" or #r.type.fields == 0
end

-- Construct a `inclua_push`
local function make_push(name)
	return string.format("inclua_push(L, %s);", name)
end
-- Construct a `inclua_push_array`
local function make_push_array(name, size)
	local s
	if type(size) == "table" then
		s = table.concat(sizes, ", ")
	else
		s = size
	end
	return string.format("inclua_push_array(L, %s, %s);", name, s)
end
-- Get the Array dims
local function get_array_dims_check(sizes)
	return table.concat(tablex.imap(function(s)
		return (s == "_" or s == "NULL") and "(size_t *) NULL" or ("&" .. s)
	end, sizes), ", ")
end
local function get_array_dims_new(sizes)
	return table.concat(tablex.imap(function(s)
		return (s == "_" or s == "NULL") and "(size_t *) NULL" or s
	end, sizes), ", ")
end
local function get_delete_array_args(argname, sizes)
	return argname .. table.concat(tablex.imap(function(s)
		return ", " .. (s == "_" and "NULL" or s)
	end, tablex.sub(sizes, 2)))
end
%}

/* Inclua Lua wrapper generator
 * ============================
 * What you should know:
 * 
 * - generated code is C++11
 * - nothing is defined in global scope, everything is in the module table
 * - doesn't yet support input default arguments
 * - non opaque structs/unions can be instantiated with the `new` function from
 *   it's metatable: `obj = my_module.struct_metatable.new ()`
 * - all structs/unions may index it's metatable if the key isn't present as a
 *   field. This way it is easy to include methods (and metamethods):
 *   `my_module.struct_metatable.__tostring = my_module.print_struct
 *   print(some_struct_in_memory)
 *   my_module.struct_metatable.someFunc = my_module.someFunc
 *   some_struct_in_memory:someFunc(extra_args)`
 * - every struct/union pointer is a Lua full userdata, which means that equality
 *   between pointers doesn't work like expected. This will be fixed soon
 * - all output parameters that are pointers are initialized with NULL, as some
 *   functions may relly on that to know if it worked
 * - structs/unions that have function pointers as fields cannot be bound
 */

#ifndef INCLUA_LUA_HPP
#define INCLUA_LUA_HPP

#include "lua.hpp"
#include <cstdlib>
#include <cstring>
#include <cstdint>
#include <type_traits>

////////////////////////////////////////////////////////////////////////////////
//  Native types
////////////////////////////////////////////////////////////////////////////////
template<typename T> void inclua_push(lua_State *L, T val) {
	typedef typename std::remove_cv<T>::type noCV;
	static_assert(!std::is_same<T, noCV>::value, "Type not yet registered in inclua_push");
	inclua_push<noCV>(L, val);
}

template<> void inclua_push(lua_State *L, bool b) {
	lua_pushboolean(L, b);
}

template<> void inclua_push(lua_State *L, char c) {
	lua_pushlstring(L, &c, sizeof (char));
}

template<> void inclua_push(lua_State *L, int8_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, int16_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, int32_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, int64_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, long long int i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, uint8_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, uint16_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, uint32_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, uint64_t i) {
	lua_pushinteger(L, i);
}
template<> void inclua_push(lua_State *L, unsigned long long int i) {
	lua_pushinteger(L, i);
}

template<> void inclua_push(lua_State *L, float flt) {
	lua_pushnumber(L, flt);
}
template<> void inclua_push(lua_State *L, double flt) {
	lua_pushnumber(L, flt);
}
template<> void inclua_push(lua_State *L, long double flt) {
	lua_pushnumber(L, flt);
}

template<> void inclua_push(lua_State *L, const char *str) {
	if(str) {
		lua_pushstring(L, str);
	}
	else {
		lua_pushnil(L);
	}
}
template<> void inclua_push(lua_State *L, char *str) {
	if(str) {
		lua_pushstring(L, str);
	}
	else {
		lua_pushnil(L);
	}
}

template<> void inclua_push(lua_State *L, void *ptr) {
	lua_pushlightuserdata(L, ptr);
}


template<typename T> T inclua_check(lua_State *L, int arg) {
	typedef typename std::remove_cv<T>::type noCV;
	return inclua_check<noCV>(L, arg);
}

template<> bool inclua_check(lua_State *L, int arg) {
	return lua_toboolean(L, arg);
}

template<> char inclua_check(lua_State *L, int arg) {
	return *luaL_checkstring(L, arg);
}

template<> int8_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> int16_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> int32_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> int64_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> long long int inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> uint8_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> uint16_t inclua_check (lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> uint32_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> uint64_t inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}
template<> unsigned long long int inclua_check(lua_State *L, int arg) {
	return luaL_checkinteger(L, arg);
}

template<> float inclua_check(lua_State *L, int arg) {
	return luaL_checknumber(L, arg);
}
template<> double inclua_check(lua_State *L, int arg) {
	return luaL_checknumber(L, arg);
}
template<> long double inclua_check(lua_State *L, int arg) {
	return luaL_checknumber(L, arg);
}

template<> const char *inclua_check(lua_State *L, int arg) {
	return lua_isnoneornil(L, arg) ? NULL : luaL_checkstring(L, arg);
}

template<> void *inclua_check(lua_State *L, int arg) {
	void *ptr = lua_touserdata(L, arg);
	// if full userdata, do the uservalue trick
	if(lua_type(L, arg) == LUA_TUSERDATA) {
		if(lua_getuservalue(L, arg) != LUA_TBOOLEAN) {
			ptr = *((void **) ptr);
		}
		lua_pop(L, 1);
	}
	return ptr;
}

////////////////////////////////////////////////////////////////////////////////
//  Records: Structs/Unions
////////////////////////////////////////////////////////////////////////////////
#define INCLUA_PUSH(record_name) \
	template<> void inclua_push(lua_State *L, record_name *ptr) { \
		if(ptr) { \
			record_name **block = (record_name **) lua_newuserdata (L, sizeof (void *)); \
			luaL_setmetatable(L, #record_name); \
			*block = ptr; \
		} \
		else { \
			lua_pushnil(L); \
		} \
	}

#define INCLUA_PUSH_NON_OPAQUE(record_name) \
	template<> void inclua_push(lua_State *L, record_name obj) { \
		record_name **block = (record_name **) lua_newuserdata(L, sizeof(void *)); \
		luaL_setmetatable(L, #record_name); \
		*block = &obj; \
	}

#define INCLUA_CHECK(record_name) \
	template<> record_name *inclua_check(lua_State *L, int arg) { \
		if (lua_isnoneornil(L, arg)) { \
			return NULL; \
		} \
		else { \
			record_name *ptr = (record_name *) luaL_checkudata(L, arg, #record_name); \
			if (lua_getuservalue(L, arg) != LUA_TBOOLEAN) { \
				ptr = *((record_name **) ptr); \
			} \
			lua_pop(L, 1); \
			return ptr; \
		} \
	}

#define INCLUA_CHECK_NON_OPAQUE(record_name) \
	template<> record_name inclua_check(lua_State *L, int arg) { \
		return *(inclua_check<record_name *>(L, arg)); \
	}

int inclua_record_eq(lua_State *L) {
	void *obj1 = inclua_check<void *>(L, 1);
	void *obj2 = inclua_check<void *>(L, 2);
	lua_pushboolean(L, obj1 == obj2);
	return 1;
}

////////////////////////////////////////////////////////////////////////////////
//  Enums
////////////////////////////////////////////////////////////////////////////////
#define INCLUA_PUSH_ENUM(enum_name) \
	template<> void inclua_push(lua_State *L, enum_name value) { \
		inclua_push<int>(L, value); \
	}

#define INCLUA_CHECK_ENUM(enum_name) \
	template<> enum_name inclua_check(lua_State *L, int arg) { \
		return (enum_name) inclua_check<int>(L, arg); \
	}

////////////////////////////////////////////////////////////////////////////////
//  Array types
////////////////////////////////////////////////////////////////////////////////

template<typename T, typename = std::enable_if<std::is_pointer<T>::value>>
void inclua_push_array(lua_State *L, T arr, size_t size) {
	lua_newtable (L);
	for(int i = 0; i < size; i++) {
		inclua_push(L, arr[i]);
		lua_seti(L, -2, i + 1);
	}
}
template<typename T, typename = std::enable_if<std::is_pointer<T>::value>, typename... Sizes>
void inclua_push_array(lua_State *L, T arr, size_t size, Sizes... tail) {
	lua_newtable(L);
	for(int i = 0; i < size; i++) {
		inclua_push_array(L, arr[i], tail...);
		lua_seti(L, -2, i + 1);
	}
}
template<>
void inclua_push_array(lua_State *L, char *arr, size_t size) {
	// char array? Ah, string it is!
	lua_pushlstring(L, arr, size);
}


#define remove_cv_from_ptr(T) typename std::remove_cv<typename std::remove_pointer<T>::type>::type
template<typename T, typename = std::enable_if<std::is_pointer<T>::value>, typename... Sizes>
T inclua_check_array(lua_State *L, int arg, size_t * size, Sizes... tail) {
	typedef remove_cv_from_ptr(T) pointeeType;
	// check for NULL array
	if(lua_isnoneornil(L, arg)) {
		if(size) {
			*size = 0;
		}
		return NULL;
	}

	int len = luaL_len(L, arg);
	luaL_argcheck(L, len >= 0, arg, "Array length should be a positive integer");
	if(size) {
		*size = len;
	}
	pointeeType * ret = new pointeeType[len];
	arg = lua_absindex(L, arg);
	for(int i = 0; i < len; i++) {
		lua_geti(L, arg, i + 1);
		ret[i] = inclua_check_array<pointeeType>(L, -1, tail...);
	}
	lua_pop(L, len);
	return ret;
}
template<typename T, typename = std::enable_if<std::is_pointer<T>::value>>
T inclua_check_array(lua_State *L, int arg, size_t * size) {
	typedef remove_cv_from_ptr(T) pointeeType;
	// check for NULL array
	if(lua_isnoneornil(L, arg)) {
		if(size) {
			*size = 0;
		}
		return NULL;
	}

	int len = luaL_len(L, arg);
	luaL_argcheck(L, len >= 0, arg, "Array length should be a positive integer");
	if(size) {
		*size = len;
	}
	pointeeType * ret = new pointeeType[len];
	arg = lua_absindex(L, arg);
	for(int i = 0; i < len; i++) {
		lua_geti(L, arg, i + 1);
		ret[i] = inclua_check<pointeeType>(L, -1);
	}
	lua_pop(L, len);
	return ret;
}
template<>
const char * inclua_check_array(lua_State *L, int arg, size_t * size) {
	// char array? Ah, string it is!
	return luaL_checklstring(L, arg, size);
}


template<typename T, typename = std::enable_if<std::is_pointer<T>::value>>
T inclua_new_array(size_t size) {
	typedef remove_cv_from_ptr(T) pointeeType;
	return new pointeeType[size];
}
template<typename T, typename = std::enable_if<std::is_pointer<T>::value>, typename... Sizes>
T inclua_new_array(size_t size, Sizes... tail) {
	typedef remove_cv_from_ptr(T) pointeeType;
	auto ret = new pointeeType[size];
	for(size_t i = 0; i < size; i++) {
		ret[i] = inclua_new_array<pointeeType>(tail...);
	}
	return ret;
}


template<typename T, typename = std::enable_if<std::is_pointer<T>::value>>
void inclua_delete_array(T arr) {
	delete[] arr;
}
template<typename T, typename = std::enable_if<std::is_pointer<T>::value>>
void inclua_delete_array(T arr, size_t size) {
	for (size_t i = 0; i < size; i++) {
		inclua_delete_array(arr[i]);
	}
	delete[] arr;
}
template<typename T, typename = std::enable_if<std::is_pointer<T>::value>, typename... Sizes>
void inclua_delete_array(T arr, size_t size, Sizes... tail) {
	for (size_t i = 0; i < size; i++) {
		inclua_delete_array(arr[i], tail...);
	}
	delete[] arr;
}

template<>
void inclua_delete_array(const char * arr) {
	// in Lua, the strings from luaL_checkstring are internal, so no need to delete'em
}

#undef remove_cv_from_ptr
#endif

{% for _, h in ipairs(headers) do %}
#include "{{ h }}"
{% end %}

{% --- PUSH/CHECK --- %}
{% for _, r in ipairs(records) do %}
// Push/Check {{ r.alias or r.name }} 
{%   if is_anonymous(r) then %}
{{ r.name }} {
{%     for _, field in ipairs(r.type.fields) do %}
	{{ field[2].name }} {{ field[1] }};
{%     end %}
};
{%   end %}
INCLUA_PUSH({{ r.name }});
INCLUA_CHECK({{ r.name }});
{%   if not is_opaque(r) then %}
INCLUA_PUSH_NON_OPAQUE({{ r.name }});
INCLUA_CHECK_NON_OPAQUE({{ r.name }});
{%   end %}
{% end %}

{% for _, e in ipairs(enums) do %}
////////////////////////////////////////////////////////////////////////////////
//  {{ e.alias or e.name }} 
////////////////////////////////////////////////////////////////////////////////
{%   if not is_anonymous(e) then %}
INCLUA_PUSH_ENUM({{ e.name }});
INCLUA_CHECK_ENUM({{ e.name }});
{%   else %}
// Anonymous enum
{%   end %}
void inclua_register_{{ space2_(e.name) }}(lua_State *L) {
{%   local scope = e.parent and trim_prefix(e.parent.name) .. "::" or ""
	 for _, v in ipairs(e.values) do %}
	inclua_push<int>(L, {{ scope }}{{ v.name }}); lua_setfield(L, -2, "{{ v.alias or v.name }}");
{%   end %}
}
{% end %}

{% for _, r in ipairs(records) do %}
{%   local normalized = space2_(r.name) %}
////////////////////////////////////////////////////////////////////////////////
//  {{ r.alias or r.name }} 
////////////////////////////////////////////////////////////////////////////////
{%   if not is_opaque(r) then %}
{%     if not is_anonymous(r) then %}
int inclua_push_new_{{ normalized }}(lua_State *L) {
	lua_newuserdata(L, sizeof ({{ r.name }}));
	luaL_setmetatable(L, "{{ r.name }}");
	// Mark userdata as non-pointer
	lua_pushboolean(L, 1);
	lua_setuservalue(L, -2);
	return 1;
}
{%     end %}
int inclua_index_{{ normalized }}(lua_State *L) {
	auto obj = inclua_check<{{ r.name }} *>(L, 1);
	const char *key = inclua_check<const char *>(L, 2);

{%     for i, f in ipairs(r.type.fields) do
         local els = i == 1 and "" or "else "
		 local field, ty = f[1], f[2]
		 local ref = ty.kind == "record" and (is_anonymous(ty) and "(" .. ty.name .. " *) &" or "&") or ""
		 if ty.kind ~= "enum" then
%}
	{{ els }}if(strcmp(key, "{{ field }}") == 0) inclua_push(L, {{ ref }}obj->{{ field }});
{%       else %}
	{{ els }}if(strcmp(key, "{{ field }}") == 0) inclua_push(L, (int)obj->{{ field }});
{%       end %}
{%     end %}
{%     if not is_anonymous(r) then %}
	else {  // Index metatable, may return nil
		luaL_getmetatable(L, "{{ r.name }}");
		lua_getfield(L, -1, key);
		lua_rotate(L, -2, 1);
		lua_pop(L, 1);
	}
{%     else %}
	else return luaL_error (L, "{{ r.alias or r.name }} doesn't have a \"%s\" field", key);
{%     end %}
	return 1;
}

int inclua_new_index_{{ normalized }}(lua_State *L) {
	auto obj = inclua_check<{{ r.name }} *>(L, 1);
	const char *key = inclua_check<const char *>(L, 2);

{%     for i, f in ipairs(r.type.fields) do
         local els = i == 1 and "" or "else "
		 local field, ty = f[1], f[2]
		 if not is_anonymous(ty) then
		   if ty.kind ~= "enum" then
%}
	{{ els }}if(strcmp(key, "{{ field }}") == 0) obj->{{ field }} = inclua_check<{{ ty.name }}>(L, 3);
{%         else %}
	{{ els }}if(strcmp(key, "{{ field }}") == 0) obj->{{ field }} = ({{ ty.name }}) inclua_check<int>(L, 3);
{%         end %}
{%       end %}
{%     end %}
	else return luaL_error(L, "{{ r.alias or r.name }} doesn't have a \"%s\" field", key);
	return 0;
}
{%   end %}

void inclua_register_{{ normalized }}(lua_State *L) {
	if(luaL_newmetatable(L, "{{ r.name }}")) {
{%   if is_opaque(r) then %}
		lua_pushvalue (L, -1);
		lua_setfield(L, -2, "__index");
		lua_pushcfunction(L, inclua_record_eq);
		lua_setfield(L, -2, "__eq");
{%   else %}
		const luaL_Reg metamethods[] = {
			{ "__index", inclua_index_{{ normalized }} },
			{ "__newindex", inclua_new_index_{{ normalized }} },
			{ "__eq", inclua_record_eq },
{%     if not is_anonymous(r) then %}
			{ "new", inclua_push_new_{{ normalized }} },
{%     end %}
			{ NULL, NULL },
		};
		luaL_setfuncs(L, metamethods, 0);
{%   end %}
		lua_pushliteral(L, "{{ r.name }}");
		lua_setfield(L, -2, "__metatable");
	}
}
{% end %}
////////////////////////////////////////////////////////////////////////////////
//  Functions
////////////////////////////////////////////////////////////////////////////////
{% for _, f in ipairs(functions) do %}
int wrap_{{ f.name }}(lua_State *L) {
{%   if f.notes == "native" then -- just tail call %}
	return {{ f.name }}(L);
{%   else
       -- Declare arguments
	   local array_decl, arg_call = {}, {}
	   local frees, returns = {}, {}
	   local i_stack, i_size = 1, 1
	   local default_note = {kind = "in"}
	   for i, ty in ipairs(f.type.arguments) do
		 local argname = "arg" .. i
         local note = f.notes and f.notes[i] or default_note
		 local kind = note.kind
		 -- Argument call: 
		 if kind == "out" or kind == "inout" or kind == "size out" then
			 table.insert(arg_call, "&" .. argname)
		 else
			 table.insert(arg_call, argname)
		 end
		 -- Argument declaration
		 if kind == "in" then %}
	{{ ty.name }} {{ argname }} = inclua_check<{{ ty.name }}>(L, {{ i_stack }});
{%         i_stack = i_stack + 1
         elseif kind == "out" then %}
	{{ ty.element_type.name }} {{ argname }}{{ ty.element_type.kind == "pointer" and " = nullptr" or "" }};
{%		   table.insert(returns, argname)
           if note.free then
			 table.insert(frees, {note.free, argname})
		   end
         elseif kind == "inout" then %}
	{{ ty.element_type.name }} {{ argname }} = inclua_check<{{ ty.element_type.name }}>(L, {{ i_stack }});
{%         i_stack = i_stack + 1
		   table.insert(returns, argname)
           if note.free then
			 table.insert(frees, {note.free, argname})
		   end
		 elseif kind == "array in" then
		   local size = get_array_dims_check(note.dims)
		   table.insert(array_decl, {
		     ty = ty.name,
			 argname = argname,
			 i_stack = i_stack,
			 size = size
		   })
 		   table.insert(frees, {"inclua_delete_array", get_delete_array_args(argname, note.dims)})
		   i_stack = i_stack + 1
	     elseif kind == "array out" then
		   local size = get_array_dims_new(note.dims)
		   table.insert(array_decl, {
		     ty = ty.name,
			 argname = argname,
			 out = true,
			 size = size
		   })
 		   table.insert(frees, {"inclua_delete_array", get_delete_array_args(argname, note.dims)})
		   table.insert(returns, {name = argname, size = size})
		 elseif kind == "size in" then %}
	size_t {{ argname }};
{%       elseif kind == "size out" then %}
	{{ ty.element_type.name }} {{ argname }};
{%
	     else
			 print("Nota não encontrada:\"" .. kind .. "\"")
		 end
       end

	   for _, arr in ipairs(array_decl) do %}
	{{ arr.ty }} {{ arr.argname }} = inclua_{{ arr.out and "new" or "check" }}_array<{{ arr.ty }}>({%
	     if not arr.out then %}
L, {{ arr.i_stack }}, {%
         end %}
{{ arr.size }});
{%     end
	   -- Call the function
       local maybe_return
       if f.type.result_type.kind == "void" then
		 maybe_return = ""
	   else
		 maybe_return = f.type.result_type.name .. " ret = "
		 -- check for return notes
		 local return_note = f.notes and f.notes[#f.type.arguments + 1]
		 if return_note == nil then
		   table.insert(returns, 1, "ret")
	     elseif return_note.kind == "out" then
		   table.insert(returns, 1, "ret")
		   if return_note.free then
			 table.insert(frees, {return_note.free, "ret"})
		   end
		 elseif return_note.kind == "array out" then
		   local size = get_array_dims_new(return_note.dims)
 		   table.insert(frees, {"inclua_delete_array", get_delete_array_args("ret", return_note.dims)})
		   table.insert(returns, {name = "ret", size = size})
	     else
		   error(string.format('Invalid note for the return of function "%s": "%s"', f.name, return_note.kind))
		 end
	   end
%}
	{{ maybe_return }}{{ f.name }}({{ table.concat(arg_call, ", ") }});
{%     -- Return stuff
       for _, r in ipairs(returns) do
	     if type(r) == "string" then %}
	{{ make_push(r) }} 
{%       else %}
	{{ make_push_array(r.name, r.size) }} 
{%       end %}
{%     end %}
{%     -- Free stuff
       for _, pair in ipairs(frees) do %}
	{{ pair[1] }}({{ pair[2] }});
{%     end %}
	return {{ #returns }};
{%   end %}
}
{% end %}

////////////////////////////////////////////////////////////////////////////////
//  Module initialization
////////////////////////////////////////////////////////////////////////////////
extern "C" int luaopen_{{ module_name }}(lua_State *L) {
	const luaL_Reg functions[] = {
{% for _, f in ipairs(functions) do %}
		{ "{{ f.alias or f.name }}", wrap_{{ f.name }} },
{% end %}
		{ NULL, NULL },
	};
	luaL_newlib(L, functions);

{% for _, r in ipairs(records) do %}
{%   local name = r.alias or r.name %}
	// {{ name }} 
	inclua_register_{{ space2_(r.name) }}(L);
	lua_setfield(L, -2, "{{ trim_prefix(name) }}");

{% end %}
{% for _, e in ipairs(enums) do %}
{%   local name = e.alias or e.name %}
	// {{ name }} 
{% if e.notes == 'scope' then %}	lua_newtable(L);{% end %}
	inclua_register_{{ space2_(e.name) }}(L);
{% if e.notes == 'scope' then %}	lua_setfield(L, -2, "{{ name }}");{% end %}
	
{% end %}
{% for k, v in pairs(constants) do %}
	// constant {{ k }} 
	inclua_push(L, {{ v }});
	lua_setfield(L, -2, "{{ k }}");

{% end %}
	// lua_State for function arguments
	//callback_State = L;

	return 1;
}
